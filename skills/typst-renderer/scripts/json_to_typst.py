#!/usr/bin/env python3
"""
JSON to Typst Data Converter for Rescume v2.0

Converts structured JSON resume content into Typst variable declarations.
Handles string escaping, nested structures, and type conversions.
"""

import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Union


def escape_typst_string(s: str) -> str:
    """
    Escape special characters for Typst strings.

    Typst string literals use quotes and need escaping for:
    - Quotes (" and ')
    - Backslashes
    - Hash symbols (#)
    """
    if not isinstance(s, str):
        return str(s)

    # Escape backslashes first
    s = s.replace('\\', '\\\\')
    # Escape quotes
    s = s.replace('"', '\\"')
    # Escape hash (used for Typst interpolation)
    s = s.replace('#', '\\#')

    return s


def json_value_to_typst(value: Any, indent_level: int = 0) -> str:
    """
    Convert a JSON value to Typst syntax.

    Supports:
    - Strings → "string"
    - Numbers → 123 or 123.45
    - Booleans → true/false
    - null → none
    - Arrays → (item1, item2, )
    - Objects → (key1: value1, key2: value2, )
    """
    indent = "  " * indent_level

    if value is None:
        return "none"

    elif isinstance(value, bool):
        return "true" if value else "false"

    elif isinstance(value, (int, float)):
        return str(value)

    elif isinstance(value, str):
        return f'"{escape_typst_string(value)}"'

    elif isinstance(value, list):
        if not value:
            return "()"

        # Arrays in Typst: (item1, item2, item3, )
        # Note the trailing comma for single-element arrays
        items = []
        for item in value:
            typst_item = json_value_to_typst(item, indent_level + 1)
            items.append(f"{indent}  {typst_item}")

        items_str = ",\n".join(items)
        return f"(\n{items_str},\n{indent})"

    elif isinstance(value, dict):
        if not value:
            return "()"

        # Objects in Typst: (key1: value1, key2: value2)
        pairs = []
        for key, val in value.items():
            # Keys in Typst don't need quotes if they're valid identifiers
            # For safety, we'll use identifiers without special chars
            safe_key = key.replace("-", "_").replace(" ", "_")
            typst_val = json_value_to_typst(val, indent_level + 1)

            # Format based on complexity
            if "\n" in typst_val:
                # Multi-line value
                pairs.append(f"{indent}  {safe_key}: {typst_val}")
            else:
                # Single-line value
                pairs.append(f"{indent}  {safe_key}: {typst_val}")

        pairs_str = ",\n".join(pairs)
        return f"(\n{pairs_str},\n{indent})"

    else:
        # Fallback: convert to string
        return f'"{escape_typst_string(str(value))}"'


def convert_json_to_typst(json_data: Dict[str, Any]) -> str:
    """
    Convert complete JSON resume data to Typst data file.

    Returns a Typst file content with #let statements defining the data structure.
    """
    # Convert the JSON to Typst dictionary format
    typst_data = json_value_to_typst(json_data, indent_level=0)

    # Create the complete Typst file
    typst_content = f"""// Resume data generated by Rescume v2.0
// Auto-generated from JSON - do not edit manually

#let resume_data = {typst_data}
"""

    return typst_content


def main():
    """CLI entry point."""
    if len(sys.argv) < 2:
        print("Usage: json_to_typst.py <input.json> [output.typ]")
        print("  If output.typ is omitted, prints to stdout")
        sys.exit(1)

    input_path = Path(sys.argv[1])

    if not input_path.exists():
        print(f"Error: Input file not found: {input_path}", file=sys.stderr)
        sys.exit(2)

    try:
        # Load JSON
        with open(input_path, 'r', encoding='utf-8') as f:
            json_data = json.load(f)

        # Convert to Typst
        typst_content = convert_json_to_typst(json_data)

        # Output
        if len(sys.argv) >= 3:
            output_path = Path(sys.argv[2])
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(typst_content)
            print(f"✓ Converted {input_path} → {output_path}")
        else:
            print(typst_content)

        sys.exit(0)

    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON: {e}", file=sys.stderr)
        sys.exit(3)

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
